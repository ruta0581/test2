<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Client</title>
  <meta charset="utf-8">
  <style>
    html, body {
      width: 100vw; height: 100vh;
      margin: 0; padding: 0;
      background: #101015;
      overflow: hidden;
    }
    #mainArea {
      width:100vw; height:100vh; display:flex; align-items:center; justify-content:center;
    }
    #remoteVideo {
      width: 1280px;
      height: 720px;
      background: #111;
      display: block;
      margin: 0 auto;
      object-fit: contain;
      box-shadow: 0 0 24px #000a;
    }
    #connBox {
      position: absolute;
      top: 24px;
      left: 0; width: 100vw;
      text-align: center;
      background: #222;
      color: #eee;
      padding: 8px 0;
      z-index: 10;
    }
    #connBox input { width:340px; }
    #connBox button { font-size:1em; padding: 0.3em 1.4em; }
    #errorBox {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none; /* エラー表示中も入力欄にはアクセス可能 */
      z-index: 100;
    }
    #errorMsg {
      background: #e11; color: #fff; padding: 2em 3em; font-size: 2em;
      border-radius: 20px; font-weight: bold; box-shadow: 0 0 32px #000c;
      pointer-events: auto;
      display: none;
    }
  </style>
</head>
<body>
<div id="connBox">
  WSSアドレス:
  <input id="wssUrl" placeholder="http(s)://から始まるURLのみ有効">
  <button id="connectBtn" onclick="toggleConnect()">接続</button>
</div>
<div id="errorBox">
  <div id="errorMsg"></div>
</div>
<div id="mainArea">
  <video id="remoteVideo" autoplay playsinline controls
    controlsList="nodownload noremoteplayback"
    preload="auto"
    tabindex="0"
    style="outline:none;">
  </video>
</div>
<script>
let ws = null, pc = null, dataChannel = null, dcKeepAliveInterval = null, clientId = null;
let isConnected = false, reconnectRequested = false;

// アドレスを自動補正する関数
function fixWssUrl(raw) {
  let url = raw.trim();
  if (/^wss:\/\/.+\/ws$/.test(url)) return url;
  if (/^wss:\/\//.test(url)) {
    if (!/\/ws$/.test(url)) url += "/ws";
    return url;
  }
  // http(s):// → wss://
  url = url.replace(/^https?:\/\//, "wss://");
  if (!/\/ws$/.test(url)) url += "/ws";
  return url;
}

// エラーメッセージ表示・非表示
function showError(msg) {
  const box = document.getElementById("errorMsg");
  box.textContent = msg;
  box.style.display = "block";
  setTimeout(() => { box.style.display = "none"; }, 3500);
}
function setConnectButton(state) {
  const btn = document.getElementById("connectBtn");
  if (state === "connect") {
    btn.textContent = "接続";
    btn.disabled = false;
  } else if (state === "disconnect") {
    btn.textContent = "切断";
    btn.disabled = false;
  } else if (state === "waiting") {
    btn.textContent = "待機中…";
    btn.disabled = true;
  }
}

function toggleConnect() {
  if (!isConnected) {
    connect();
  } else {
    disconnect();
  }
}

async function connect() {
  setConnectButton("waiting");
  let urlInput = document.getElementById("wssUrl").value.trim();

  // ★ http/httpsが含まれていない場合はエラー
  if (!/^https?:\/\//.test(urlInput)) {
    showError("http:// または https:// から始まるURLを入力してください");
    setConnectButton("connect");
    return;
  }

  let wssUrl = fixWssUrl(urlInput);
  document.getElementById("wssUrl").value = wssUrl;

  ws = new WebSocket(wssUrl);
  ws.onopen = () => {
    ws.send(JSON.stringify({ role: "client" }));
    setConnectButton("disconnect");
    isConnected = true;
  };
  ws.onmessage = async ({ data }) => {
    const msg = JSON.parse(data);
    if (msg.type === "client-id") {
      clientId = msg.clientId;
      ws.send(JSON.stringify({ type: "request-offer", clientId }));
      setupPeerConnection();
    }
    if (msg.type === "offer" && msg.clientId === clientId) {
      if (!pc) setupPeerConnection();
      await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ type: "answer", answer, clientId }));
    }
    if (msg.type === "candidate" && msg.clientId === clientId) {
      if (pc && msg.candidate) {
        await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
      }
    }
    // ホストから「reconnect-video」コマンド受信時は再接続
    if (msg.type === "reconnect-video") {
      reconnectRequested = true;
      disconnect(true);
    }
  };
  ws.onclose = () => {
    setConnectButton("connect");
    isConnected = false;
    cleanupPeerConnection();
    if (reconnectRequested) {
      reconnectRequested = false;
      setTimeout(connect, 300);
    }
  };
  ws.onerror = (e) => {
    setConnectButton("connect");
    isConnected = false;
    showError("WebSocket接続エラー");
  };
}

function disconnect(shouldReconnect=false) {
  if (ws && ws.readyState === WebSocket.OPEN) ws.close();
  cleanupPeerConnection();
  setConnectButton("connect");
  isConnected = false;
  if (!shouldReconnect) reconnectRequested = false;
}

// PeerConnection + keepalive
function setupPeerConnection() {
  if (pc) cleanupPeerConnection();
  pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
  pc.ontrack = e => {
    document.getElementById("remoteVideo").srcObject = e.streams[0];
  };
  pc.onicecandidate = e => {
    if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "candidate", candidate: e.candidate, clientId }));
    }
  };
  pc.ondatachannel = (event) => {
    dataChannel = event.channel;
    dataChannel.onopen = () => {
      dcKeepAliveInterval = setInterval(() => {
        if (dataChannel.readyState === "open") dataChannel.send("keepalive");
      }, 5000);
    };
    dataChannel.onclose = () => {
      if (dcKeepAliveInterval) clearInterval(dcKeepAliveInterval);
      dcKeepAliveInterval = null;
    };
    dataChannel.onmessage = () => {};
  };
}
function cleanupPeerConnection() {
  if (dataChannel && dcKeepAliveInterval) {
    clearInterval(dcKeepAliveInterval);
    dcKeepAliveInterval = null;
  }
  dataChannel = null;
  if (pc) {
    pc.ontrack = null;
    pc.onicecandidate = null;
    pc.ondatachannel = null;
    pc.close();
    pc = null;
  }
  document.getElementById("remoteVideo").srcObject = null;
}

// --- videoのクリックでは再生/停止が絶対切り替わらないようにする ---
const video = document.getElementById("remoteVideo");
video.addEventListener("click", e => {
  // play/pauseトグルを無効化（stopPropagationでダブルで防止）
  e.preventDefault();
  e.stopPropagation();
  // ただし音量・全画面はvideoのコントロールバーでOK
});
video.addEventListener("play", e => {
  // playイベントは許可（自動再生）
});
video.addEventListener("pause", e => {
  // pauseイベントがユーザーのクリック操作で発生した場合は即座に再開
  setTimeout(()=>{ if(video.paused) video.play(); },10);
});
</script>
</body>
</html>
